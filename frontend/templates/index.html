<!DOCTYPE html>
<html lang="en" class="bg-slate-950">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Hypocrisy Detector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100">
    <header class="border-b border-slate-800 bg-slate-900/80 backdrop-blur">
      <div class="mx-auto flex max-w-5xl flex-col gap-2 px-6 py-6">
        <h1 class="text-3xl font-semibold tracking-tight">Hypocrisy Detector</h1>
        <p class="text-sm text-slate-400">
          Capture speech, upload transcripts, or paste text. Then run contradiction search against the curated corpus.
        </p>
      </div>
    </header>

    <main class="mx-auto max-w-5xl space-y-10 px-6 py-10">
      <section class="rounded-xl border border-slate-800 bg-slate-900/70 p-6 shadow-lg shadow-slate-950/40">
        <h2 class="text-xl font-semibold">1. Record speech</h2>
        <p class="mt-1 text-sm text-slate-400">Use your microphone to capture a short statement. Audio stays on this device.</p>
        <div class="mt-4 flex flex-wrap items-center gap-4">
          <button
            id="start-record"
            class="rounded-md bg-emerald-500 px-4 py-2 font-medium text-slate-950 transition hover:bg-emerald-400 disabled:opacity-40"
          >
            Start recording
          </button>
          <button
            id="stop-record"
            class="rounded-md bg-rose-500 px-4 py-2 font-medium text-slate-100 transition hover:bg-rose-400 disabled:opacity-40"
            disabled
          >
            Stop and transcribe
          </button>
          <span id="recording-status" class="text-sm text-slate-300">Microphone idle.</span>
        </div>
      </section>

      <section class="grid gap-6 md:grid-cols-2">
        <article class="rounded-xl border border-slate-800 bg-slate-900/70 p-6 shadow-lg shadow-slate-950/40">
          <h2 class="text-xl font-semibold">2. Text workspace</h2>
          <p class="mt-1 text-sm text-slate-400">Paste or edit the transcript before running detection or ingesting it.</p>
          <label class="mt-4 block text-xs font-semibold uppercase tracking-wide text-slate-500" for="text-title">Source title</label>
          <input
            id="text-title"
            type="text"
            class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950/60 px-3 py-2 text-sm text-slate-100 focus:border-emerald-400 focus:outline-none"
            placeholder="Live capture"
          />
          <label class="mt-4 block text-xs font-semibold uppercase tracking-wide text-slate-500" for="statement-input">Statement text</label>
          <textarea
            id="statement-input"
            rows="6"
            class="mt-1 w-full rounded-md border border-slate-700 bg-slate-950/60 px-3 py-2 text-sm text-slate-100 focus:border-emerald-400 focus:outline-none"
            placeholder="The sky is definitely green today."
          ></textarea>
          <div class="mt-4 flex flex-wrap items-center gap-3">
            <button
              id="ingest-text"
              class="rounded-md bg-sky-500 px-4 py-2 text-sm font-semibold text-slate-900 transition hover:bg-sky-400 disabled:opacity-40"
            >
              Ingest typed text
            </button>
            <button
              id="run-detect"
              class="rounded-md bg-indigo-500 px-4 py-2 text-sm font-semibold text-slate-50 transition hover:bg-indigo-400 disabled:opacity-40"
            >
              Run hypocrisy check
            </button>
            <span id="text-status" class="text-sm text-slate-400"></span>
          </div>
        </article>

        <article class="rounded-xl border border-slate-800 bg-slate-900/70 p-6 shadow-lg shadow-slate-950/40">
          <h2 class="text-xl font-semibold">3. Import caption or scrape data</h2>
          <div class="mt-4 space-y-5 text-sm text-slate-300">
            <div>
              <label class="block text-xs font-semibold uppercase tracking-wide text-slate-500" for="subtitle-file">Upload SRT or VTT</label>
              <input
                id="subtitle-file"
                type="file"
                accept=".srt,.vtt"
                class="mt-1 w-full rounded-md border border-dashed border-slate-700 bg-slate-950/40 px-3 py-2 text-sm"
              />
              <input
                id="subtitle-title"
                type="text"
                class="mt-2 w-full rounded-md border border-slate-700 bg-slate-950/60 px-3 py-2 text-sm text-slate-100 focus:border-emerald-400 focus:outline-none"
                placeholder="Sample subtitle"
              />
              <button
                id="upload-subtitle"
                class="mt-3 rounded-md bg-amber-500 px-4 py-2 text-sm font-semibold text-slate-900 transition hover:bg-amber-400 disabled:opacity-40"
              >
                Ingest caption file
              </button>
            </div>
            <div class="rounded-lg border border-slate-800 bg-slate-950/60 p-4">
              <h3 class="text-sm font-semibold text-slate-200">Optional scrape</h3>
              <p class="mt-1 text-xs text-slate-400">Fetch recent items and store them under data/raw/scraped.sqlite.</p>
              <div class="mt-3 flex flex-col gap-2 text-xs text-slate-300">
                <label class="inline-flex items-center gap-2">
                  <input type="checkbox" value="govuk" class="provider-toggle" checked />
                  GOV.UK speeches
                </label>
                <label class="inline-flex items-center gap-2">
                  <input type="checkbox" value="whitehouse" class="provider-toggle" checked />
                  White House briefings
                </label>
                <label class="inline-flex items-center gap-2">
                  <input type="checkbox" value="youtube" class="provider-toggle" />
                  YouTube transcripts
                </label>
              </div>
              <div class="mt-3 flex flex-wrap items-center gap-2">
                <input
                  id="scrape-since"
                  type="date"
                  class="rounded-md border border-slate-700 bg-slate-950/60 px-2 py-1 text-xs text-slate-100 focus:border-emerald-400 focus:outline-none"
                  placeholder="2024-01-01"
                />
                <input
                  id="scrape-limit"
                  type="number"
                  min="1"
                  class="w-24 rounded-md border border-slate-700 bg-slate-950/60 px-2 py-1 text-xs text-slate-100 focus:border-emerald-400 focus:outline-none"
                  placeholder="50"
                />
                <label class="inline-flex items-center gap-2 text-xs">
                  <input type="checkbox" id="scrape-ingest" />
                  Ingest into corpus
                </label>
                <button
                  id="run-scrape"
                  class="rounded-md bg-teal-500 px-4 py-2 text-xs font-semibold text-slate-950 transition hover:bg-teal-400 disabled:opacity-40"
                >
                  Run scraper
                </button>
              </div>
              <p id="scrape-status" class="mt-2 text-xs text-slate-400"></p>
            </div>
          </div>
        </article>
      </section>

      <section class="rounded-xl border border-slate-800 bg-slate-900/70 p-6 shadow-lg shadow-slate-950/40">
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold">4. Results</h2>
          <span id="result-count" class="text-xs uppercase tracking-wide text-slate-500">Awaiting run</span>
        </div>
        <div class="mt-4 overflow-x-auto">
          <table class="min-w-full divide-y divide-slate-800 text-sm">
            <thead class="bg-slate-900/80 text-xs uppercase tracking-wide text-slate-400">
              <tr>
                <th class="px-3 py-2 text-left">Score</th>
                <th class="px-3 py-2 text-left">Claim</th>
                <th class="px-3 py-2 text-left">Evidence</th>
                <th class="px-3 py-2 text-left">Source</th>
                <th class="px-3 py-2 text-left">Link</th>
              </tr>
            </thead>
            <tbody id="results-body" class="divide-y divide-slate-800"></tbody>
          </table>
        </div>
      </section>
    </main>

    <script>
      const recordBtn = document.getElementById('start-record');
      const stopBtn = document.getElementById('stop-record');
      const statusEl = document.getElementById('recording-status');
      const textInput = document.getElementById('statement-input');
      const titleInput = document.getElementById('text-title');
      const textStatus = document.getElementById('text-status');
      const ingestTextBtn = document.getElementById('ingest-text');
      const detectBtn = document.getElementById('run-detect');
      const resultsBody = document.getElementById('results-body');
      const resultCount = document.getElementById('result-count');
      const subtitleFile = document.getElementById('subtitle-file');
      const subtitleTitle = document.getElementById('subtitle-title');
      const uploadSubtitleBtn = document.getElementById('upload-subtitle');
      const scrapeBtn = document.getElementById('run-scrape');
      const scrapeStatus = document.getElementById('scrape-status');

      let mediaRecorder;
      let recordedChunks = [];

      function setStatus(message) {
        statusEl.textContent = message;
      }

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        recordBtn.disabled = true;
        stopBtn.disabled = true;
        setStatus('Microphone not available in this browser.');
      }

      recordBtn.addEventListener('click', async () => {
        recordedChunks = [];
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = handleRecordingStop;
          mediaRecorder.start();
          recordBtn.disabled = true;
          stopBtn.disabled = false;
          setStatus('Recording...');
        } catch (error) {
          console.error(error);
          setStatus('Unable to access microphone.');
        }
      });

      stopBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('Processing audio...');
      });

      async function handleRecordingStop() {
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('file', blob, 'recording.webm');
        try {
          const response = await fetch('/api/transcribe', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({ detail: 'Transcription failed.' }));
            setStatus(detail.detail || 'Transcription failed.');
            return;
          }
          const data = await response.json();
          if (Array.isArray(data.segments) && data.segments.length) {
            textInput.value = data.segments.map((seg) => seg.text).join(' ');
            setStatus(`Transcribed ${data.segments.length} segments. Ingested ${data.ingested}.`);
          } else {
            setStatus('No speech detected.');
          }
        } catch (error) {
          console.error(error);
          setStatus('Network error during transcription.');
        }
      }

      ingestTextBtn.addEventListener('click', async () => {
        const text = textInput.value.trim();
        if (!text) {
          textStatus.textContent = 'Enter some text first.';
          return;
        }
        ingestTextBtn.disabled = true;
        textStatus.textContent = 'Ingesting typed text...';
        try {
          const response = await fetch('/api/ingest_text', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text, title: titleInput.value || 'Typed statement' }),
          });
          const data = await response.json();
          if (!response.ok) {
            textStatus.textContent = data.detail || 'Ingestion failed.';
          } else {
            textStatus.textContent = `Ingested ${data.ingested} statements.`;
          }
        } catch (error) {
          console.error(error);
          textStatus.textContent = 'Network error during ingestion.';
        } finally {
          ingestTextBtn.disabled = false;
        }
      });

      uploadSubtitleBtn.addEventListener('click', async () => {
        const file = subtitleFile.files[0];
        if (!file) {
          scrapeStatus.textContent = 'Select a caption file first.';
          return;
        }
        uploadSubtitleBtn.disabled = true;
        scrapeStatus.textContent = 'Uploading caption...';
        const formData = new FormData();
        formData.append('file', file);
        formData.append('title', subtitleTitle.value || file.name);
        try {
          const response = await fetch('/api/ingest_srt', {
            method: 'POST',
            body: formData,
          });
          const data = await response.json();
          if (!response.ok) {
            scrapeStatus.textContent = data.detail || 'Caption upload failed.';
          } else {
            scrapeStatus.textContent = `Ingested ${data.ingested} segments from ${data.path}.`;
          }
        } catch (error) {
          console.error(error);
          scrapeStatus.textContent = 'Network error during caption upload.';
        } finally {
          uploadSubtitleBtn.disabled = false;
        }
      });

      detectBtn.addEventListener('click', async () => {
        const text = textInput.value.trim();
        if (!text) {
          textStatus.textContent = 'Enter a statement to evaluate.';
          return;
        }
        detectBtn.disabled = true;
        textStatus.textContent = 'Running hypocrisy check...';
        try {
          const response = await fetch('/api/detect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text, top_k: 5 }),
          });
          const data = await response.json();
          if (!response.ok) {
            textStatus.textContent = data.detail || 'Detection failed.';
          } else {
            renderResults(data);
            textStatus.textContent = 'Detection complete.';
          }
        } catch (error) {
          console.error(error);
          textStatus.textContent = 'Network error during detection.';
        } finally {
          detectBtn.disabled = false;
        }
      });

      scrapeBtn.addEventListener('click', async () => {
        const providers = Array.from(document.querySelectorAll('.provider-toggle:checked')).map((input) => input.value);
        const since = document.getElementById('scrape-since').value || null;
        const limitValue = document.getElementById('scrape-limit').value;
        const limit = limitValue ? Number(limitValue) : null;
        const ingest = document.getElementById('scrape-ingest').checked;

        scrapeBtn.disabled = true;
        scrapeStatus.textContent = 'Running scraper...';
        try {
          const response = await fetch('/api/scrape', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ providers, since, limit, ingest }),
          });
          const data = await response.json();
          if (!response.ok) {
            scrapeStatus.textContent = data.detail || 'Scrape failed.';
          } else {
            const parts = Object.entries(data.summary || {})
              .map(([slug, counts]) => `${slug}: ${counts.fetched} fetched`)
              .join(', ');
            scrapeStatus.textContent = `Saved to ${data.sqlite}. ${parts}. Ingested ${data.ingested}.`;
          }
        } catch (error) {
          console.error(error);
          scrapeStatus.textContent = 'Network error during scrape.';
        } finally {
          scrapeBtn.disabled = false;
        }
      });

      function renderResults(payload) {
        resultsBody.innerHTML = '';
        const hits = payload.hits || [];
        if (!hits.length) {
          resultCount.textContent = 'No contradictions found';
          return;
        }
        resultCount.textContent = `${hits.length} results`;
        for (const hit of hits) {
          const row = document.createElement('tr');
          row.className = 'hover:bg-slate-900/80';

          const scoreCell = document.createElement('td');
          scoreCell.className = 'px-3 py-2 font-semibold text-emerald-300';
          scoreCell.textContent = hit.score.toFixed(2);

          const claimCell = document.createElement('td');
          claimCell.className = 'px-3 py-2 text-slate-200';
          claimCell.textContent = payload.statement || '';

          const evidenceCell = document.createElement('td');
          evidenceCell.className = 'px-3 py-2 text-slate-100';
          evidenceCell.textContent = hit.corpus_text;

          const sourceCell = document.createElement('td');
          sourceCell.className = 'px-3 py-2 text-slate-300';
          const details = [];
          if (hit.source_title) details.push(hit.source_title);
          if (hit.source_type) details.push(hit.source_type);
          if (hit.ts_start != null && hit.ts_end != null) {
            details.push(`${formatTime(hit.ts_start)} to ${formatTime(hit.ts_end)}`);
          }
          sourceCell.textContent = details.join(' | ');

          const linkCell = document.createElement('td');
          linkCell.className = 'px-3 py-2';
          if (hit.url_or_path) {
            const link = document.createElement('a');
            link.className = 'text-indigo-300 hover:text-indigo-200';
            link.target = '_blank';
            link.rel = 'noopener';
            let href = hit.url_or_path;
            if (!/^https?:\/\//i.test(href)) {
              href = `/${href}`;
            }
            link.href = href;
            link.textContent = 'Open';
            linkCell.appendChild(link);
          } else {
            linkCell.textContent = '-';
          }

          row.appendChild(scoreCell);
          row.appendChild(claimCell);
          row.appendChild(evidenceCell);
          row.appendChild(sourceCell);
          row.appendChild(linkCell);
          resultsBody.appendChild(row);
        }
      }

      function formatTime(seconds) {
        if (seconds == null) return '';
        const total = Math.floor(Number(seconds));
        const h = String(Math.floor(total / 3600)).padStart(2, '0');
        const m = String(Math.floor((total % 3600) / 60)).padStart(2, '0');
        const s = String(total % 60).padStart(2, '0');
        return `${h}:${m}:${s}`;
      }
    </script>
  </body>
</html>
